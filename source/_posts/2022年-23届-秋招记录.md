---
title: 2022年(23届)秋招记录
date: 2022-06-07 13:51:51
tags:
password: 19961121
message: 找完工作后再开放
---

本文对秋招做一个记录。


## 置顶
> [拓跋阿秀 - C++、OS、智力题、大数据等八股文](https://interviewguide.cn/)
> [小林coding - 八股文网站](https://xiaolincoding.com/)


## 项目总结
**TinyKV 分布式 KV 数据库**
> tinyKV 这个项目其实是 TiDB 的行式存储引擎，它是一个支持事务的分布式 KV 存储引擎，为了提供高可用性数据采用多副本存储，使用 raft 协议保证各副本之间的一致性。在高并发场景下，raft 中的 leader 很可能会成为系统的性能瓶颈，因此在项目中，数据会分片存储在不同的节点上，每一个分片有两个副本，这样一来系统中就存在多个 raft 集群，也就是 multi-raft. 为了更好的支持范围扫描，分片的方式是范围分片，每一个分片的默认大小是 96MB. 数据的存储实际上三层抽象：最底下的是物理磁盘、再上一层是节点，最后一层才是分片。一台机器上可以有多个节点，一个节点上存储着多个分片。当某个分片的数据量太大或者访问量太大，就会考虑负载均衡将该分片分裂成多个新的分片，迁移到不同的节点上。分布式事务采用的是 percolator 两阶段提交模型，实现了快照隔离级别。

**介绍 percolator**
> percolator 构建在 BigTable之上，使用多版本并发控制和两阶段提交实现了快照隔离，它的两阶段提交是对传统两阶段提交算法的优化，在一定程度上解决了协调者崩溃后整个系统 stuck 的情况。
>
> percolator 将事务相关数据存储在 data、lock 和 write 这三个 column family 中。当一个事务要提交时，它开始两阶段提交，第一阶段是预写阶段，这个阶段它会验证本次更新是否与并发事务冲突，有三种可能，第一种是冲突的事务正在更新，可以通过读取 lock CF 查看是否存在要更新数据的锁信息判断；第二种是冲突的事务已经完成了更新，可以通过读取 write CF 是否存在更新数据在本次事务开始后的更新记录来判断；第三种就是没有冲突，这时事务会将要更新的数据、该数据的锁信息和事务的开始时间戳编码后分别写入 data CF 和 lock CF，这是一个原子操作，通过 BigTable 的单行事务完成。待每个更新完成后，开始第二阶段。
>
> 由于 percolator 的锁信息没有中心节点，散落在不同的节点上，如果协调者发生故障，为了避免整个系统停滞，就需要一种方法判断当前事务的状态：如果当前事务提交了部分，那么剩下的部分也必须提交，如果当前事务还未提交，那么回滚它也就不会带来什么风险。为此 percolator 从要更新的数据中随机选择（通常是第一个）一个 key 作为 primary key 来代表当前事务的状态。事实上在第一阶段写入 lock CF 的信息就包含指向 primary key 的指针。
>
> 在第二阶段，提交阶段，协调者先提交 primary key，也就是将该数据的 lock 信息从 lock CF 中清除，同时把 key 和事务提交时间戳编码后写入 write CF 中，表示该更新对外可见，这同样是一个原子操作。primary key 提交成功后，该事务就必须被提交，后面按照同样的方式提交剩下的数据。
> 


**介绍 raft 算法**
> 在存储数据时，一般为了提供容错能力和高可用性会对数据进行冗余备份，使得发生故障后仍能对外提供服务。在 ACID 和分布式一致性模型的约束下，需要保证副本之间数据的一致性问题，一般有两种类型的解决方法：第一类是复制协议，比如单主复制、多主复制和无主复制等；第二类就是共识协议，比如 raft. 
> 
> 在 raft 算法中存在 leader 和 follower 角色，leader 负责接收客户端的请求，执行共识协议和回复客户端。当 leader 收到请求时，它会将请求封装成日志存储在本地，然后发送给每一个 follower. follower 收到日志后也会存储在本地，然后回复 leader. 若有一半甚至更多的 follower 复制日志成功，那么 leader 就会提交这个日志、执行日志中的请求然后回复客户端。 在 leader 的每一个复制请求中都会包含当前已提交的最大的日志编号，借此 follower 可以执行已提交日志中的请求，从而与 leader 的数据保持一致。
> 
> leader 节点可能会发生故障离线，为了使得 raft 集群继续提供服务，需要自发的在剩下的节点中选出新的 leader. raft 算法会在每一个节点上维持两个定时器：第一个是心跳定时器，用于 leader 定期给各个 follower 发送心跳包，用来告知当前 leader 健在；第二个是选举定时器，如果某个 follower 的选举定时器到期后还未收到 leader 的心跳包或者复制请求那么该 follower 就会认为 leader 发生了故障，自己应该发起选举选出新的 leader. follower 首先会变成 candidate，投自己一票，然后向其他所有节点发送请求索要选票。为了使得选出的 leader 具有完整的已提交的日志，raft 规定，若 candidate 比当前节点具有更新的日志，那么当前节点就会将选票投给 candidate，否则拒绝投票。一般来说，一次选举有三种结果：第一种是当前 candidate 获取超过半数的选票，成功当选 leader. 第二种是有其他 leader 出现，有可能是之前的 leader 回归，也可能是其他 candidate 当选，那么当前的 candidate 会变成 follower. 第三种是本次选举没有没有赢家，那么整个集群会等待下次选举定时器超时，再一次开始选举。为了减少第三种瓜分选票的情况出现，每一次 raft 都会随机设置每一个定时器，使得同一时间到期的节点尽可能地少。
> 
> 在 raft 中，leader 可能频繁变更，各个节点的日志可能会很混乱，为了简化算法和避免提交的日志被覆盖，raft 规定在日志复制发送冲突时，follower 必须以 leader 的日志为准，删除那些不一致的日志。前面提到选举中选出的 leader 一定会具有完整的提交的日志，可以保证这样的冲突解决是正确的。
> 
> 另外 raft 还支持增加和移除节点，这个过程是全自动的，不需要人工的干预。
> 
> raft 包含的内容比较多，上面只是简单的介绍了下。






## 八股文记录

### 分布式部分
**共识算法的种类介绍（SingleLeader，MultiLeader，Leaderless）**

<br>


**Raft 相关** 
> 见 {% post_link raft-杂记 %} <br>
> Raft 通过什么机制保证节点间 log 一致性。
> 主要讨论了旧 leader 挂掉后产生新 leader，如何保证它们对于 log commit 有一样的认知。
> raft 超过半数的决策机制如何保证 leader 日志的完整性。



<br>

**数据如何 sharding**
> {% post_link "数据分片" %} <br>
> {% post_link "一致性哈希" %}



### 数据库部分
**（MySQL）分区表作用、分区表是单机的还是分布在多机的**
> 主要是理清分库、分表、分区表之间的区别。<u>分表</u>是指将一张表分成多个具有独立存储空间的表，如把一账本表按年份分成多张表。<u>分区表</u>，一张表被分区，但逻辑上还是一张表。<u>分库</u>，库是指数据库，分库也就是将数据库分成多个小数据库。

> <u>为什么要分库</u>，因为单个数据库承接的访问量太大（QPS）快支撑不住了，如果将数据拆分放在多个数据库，那么单个数据库的访问并发量就会减少，分库主要是从 QPS 角度考虑的。<u>为什么要分表</u>，如果一个表的数据量太大，哪怕是走索引也会很慢（元组太多，B+ 树高度增加，磁盘 I/O 增加），所以可以考虑将表拆分成数个小表，查询性能就可以得到提升，另外，如果各个子表放在不同的磁盘（节点），分表还能提升查询的并行度。分库分表对比如下图。
![](/img/2022年秋招/2.jpg)
> 分区表和分表主要的区别在于分区表还是一张表，只不过 db 内部会自己将具体的操作路由到对应的分区，这些分区存储位置既可以在一起也可以在不同的磁盘（节点），[分库分表实践](https://www.modb.pro/db/438223)。

<br>

**buffer pool 有哪些替换算法**
> LRU，换出页面时优先换出最长时间未使用的页面，LRU 算法在大多数情况下表现是不错的，<u>但有一个问题</u>：假如某一个查询做了一次全表扫描，将导致缓冲池中的大量页面（可能包含很多很快被访问的热点页面）被替换，从而污染缓冲池。现代数据库一般采用 LIRS 算法，将缓冲池分为两级，数据首先进入第一级，如果数据在较短的时间内被访问两次或者以上，则成为热点数据进入第二级，每一级内部还是采用 LRU 替换算法。Oracle 数据库中的 Touch Count 算法和 MySQL InnoDB 中的替换算法都采用了类似的分级思想。以 MySQL InnoDB 为例，InnoDB 内部的 LRU 链表分为两部分：新子链表（new sublist）和老子链表（old sublist），默认情况下，前者占 5/8，后者占 3/8。页面首先插入到老子链表，InnoDB 要求页面在老子链表停留时间超过一定值，比如 1 秒，才有可能被转移到新子链表。当出现全表扫描时，InnoDB 将数据页面载入到老子链表，由于数据页面在老子链表中的停留时间不够，不会被转移到新子链表中，这就避免了新子链表中的页面被替换出去的情况.

<br>


**Lock Manager 如何实现的**
> 见 {% post_link "Lock Manager" %}. <br>

<br>

**2PL 和 S2PL，什么情况下使用 S2PL**
> 见 {% post_link "事务的并发控制" %}. <br>

<br>

**死锁避免策略**
> 见 {% post_link "事务的并发控制" %}. <br>

<br>

**数据量大，内存放不下，怎么排序**
> 参考 {% post_link "查询处理篇：Sorting" %} <br>

<br>

**B+Tree 插入时如何扩张**
> 参考 {% post_link "索引篇二：B-plus Tree" %} <br>

<br>

**binlog、redo log、undo log**
> [binlog 参考文章](https://zhuanlan.zhihu.com/p/190886874)
> [更多参考文章](https://www.zhihu.com/question/463438061/answer/2280710259)
> redo log 见 {% post_link 数据库恢复系统 %}. <br>

<br>

**全局二级索引的作用、全局二级索引的回表**
> {% post_link "索引篇四：Parallel Index" %} <br>


<br>

**如何根据不同场景选择索引**
> 假设一条 sql 语句为：slect a, b, c from R where ...
> 如果 where 条件中含有聚簇索引属性，那么应该选择该聚簇索引检索；
> 若上面不满足，如果在 where 条件中的某些属性上有普通索引：
> * 优先选择覆盖索引，如果有的话。覆盖索引包含所有条件中的字段，这样就不需要回表判断条件了。
> * 其次选择联合索引，如果有的话。注意最左前缀匹配，条件中必须包含联合索引最左侧的字段。
> * 如果上面都没有，就选择普通索引，如果有的话。比如选择多个/单个涉及到部分条件字段的索引，最后结果取交集/并集。
> * 如果还是没有，全表扫描了只有。


<br>

**数据库的并发控制和针对高并发事务的设计**


<br>

**[OLTP、OLAP 区别](https://www.zhihu.com/search?type=content&q=OLTP%E3%80%81OLAP%20%E5%8C%BA%E5%88%AB)**
> OLTP 具有如下的特点：
> * 主要的操作为增删改，少量的查（涉及少量数据）
> * 要求实时性高，事务吞吐量大
> * 数据模型一般是关系型

> OLAP 具有如下的特点：
> * 主要操作为查，做分析处理，不修改源数据，一次查询涉及大量的数据，若是关系型数据，则可能有上千行、少量的列。
> * 事务模型一般是星型、雪花型。
> * 一般要求查询响应速度 (QPS).

> 总结一下：
> OLTP 所产生的业务数据分散在不同的业务系统中，而 OLAP 往往需要将不同的业务数据集中到一起进行统一综合的分析，这时候就需要根据业务分析需求做对应的数据清洗后存储在数据仓库中，然后由数据仓库来统一提供 OLAP 分析。所以我们常说 OLTP 是数据库的应用，OLAP 是数据仓库的应用。可以将 OLAP 看作是 OLTP 的一种延展，一个让 OLTP 产生的数据发现价值的过程。


<br>

**分布式数据库解决了什么问题**
> [关于分布式数据库，你需要知道这些](https://zhuanlan.zhihu.com/p/24506940?utm_medium=social&utm_oi=814849418003099648&utm_psn=1545202029026553857&utm_source=wechat_session)
> [分布式数据库学习路线](https://www.zhihu.com/question/62464757/answer/1904784818?utm_campaign=shareopn&utm_content=group2_Answer&utm_medium=social&utm_oi=814849418003099648&utm_psn=1545198197680812032&utm_source=wechat_session)
> 分布式数据库 = 分布式 + 数据库。传统单机数据库将所有的业务数据都存储在同一台服务器上，随着数据增长，为了降低服务器的压力会有读写分离、分库分表等技术，会将数据分散到多个机器上，同时借助一些中间件来路由请求和负载均衡。我觉得这也是分布式数据库，它也包含了比如分布式事务、副本一致性、数据分片等分布式技术，不过这样的分布式数据库比较难用：分库分表数据迁移都需要手动部署，运维代价比较高。原因我觉得主要是传统的单机数据库本就不是为了分布式场景设计的。而现在的 NewSQL 从架构方面就和传统的单机数据库不同，它一般采用计算、存储分离方式，存储层大都使用写优化的 LSM KV 存储引擎，可以支持结构化、半结构化和非结构化的数据模型；计算层一般是解析 SQL 和执行 SQL. 在架构中一般还有一个类似于 Master 的集群用来负载均衡、分配时间戳等。NewSQL 和 传统的单机数据库集群相比，拓展性更好：比如支持更多的数据模型、能够管理的集群数据更大；运维很也简单：几乎所有的操作都是自动的。

<br>

**知道哪些 join 方法，分别介绍一下**
> {% post_link "查询处理篇：Join 操作" %} <br>
> {% post_link "查询处理篇：Parallel Join" %} <br>

<br>

**各个索引数据结构特点**
> B 树索引
> * 每个节点同时存储数据和键，节点间没有链表连接，做单点（单条数据）查询时，最好情况是 O(1)，最坏情况是树高，平均时间复杂度来说要好于 B+ 树，所以非关系型数据库 Mongodb 采用 B 树索引，因为它更多的是点查询。但 B 树不适合范围查询。

> B+ 树索引
> * B+ 树在 B 树上的改变主要有两点，一是非叶子节点不再存储数据，二是相邻叶子节点间采用双向链表连接。非叶子节点不存储数据，使得节点存储的索引键更多，扇出更大，树结构整体也就更矮更胖，做单点查询时具有非常稳定的时间复杂度。相邻叶子节点连接后就能支持范围查询。

> 可拓展哈希索引
> * 普通的哈希结构是静态的，无法很好应对数据的增减，可拓展哈希是一种动态哈希，能够随着记录的增长而增长，缩小而缩小，通过分裂某个 bucket 或合并多个 bucket 将数据迁移限制在单个的 bucket 中。与 B+ 树相比，可拓展哈希不支持范围查询，而且其容量增长的开销要高于 B+ 树。

> LSM 索引
> * LSM 是一种写优化的结构，无论是 SSD 还是磁盘顺序读写要远远快于随机读写，在存在大量写请求的场景，若采用 B+ 树，就可能有大量的随机访问，时间基本都花在了延迟上，LSM 采用只追加的方式更新数据，不会存在随机 I/O，能充分利用磁盘带宽，也能支持范围检索。不过 LSM 存在写放大过大，读放大等问题。



### C++ 部分
**thread_local 变量的原理**
> 在多线程应用中，多个线程访问全局变量、static 局部变量都可能产生竞争，可以通过加锁/原子操作协调。thread_local 采用另外的思路：将变量变成线程局部变量，直接不产生竞争，该变量虽然只有一个，但在各个线程中存储着不同的备份，每个线程只能操作属于自己的那一个备份。

> <u>Linux 可以通过线程特定数据</u>达到类似的效果，进程空间中会维护一个 pKeyArr 数组，每个元素记录 [使用标记, 删除器]，每个线程空间也会维护一个 tKeyArr 数组，记录着 [地址]. 当某个线程调用 pthread_create_key() 后会返回 pKeyArr 数组的一个下标 id，表明所有的 tKeyArr[id] 启用。当某个线程调用 pthread_setspecific(id, addr) 时就会为该线程的 tKeyArr[id] 绑定一个地址空间，存储着该线程的局部变量，线程可以调用 pthread_getspecific(id) 返回该地址，所有线程可以共有一个 id，但返回的地址空间却不同。另外，调用 pthread_create_key 也可能产生竞争，本来所有的线程只想申请一个 id，但却有可能调用多次 create_key 生成多个 id，所以线程特定数据还得搭配 pthread_once 函数，使得 create_key 只执行一次。

> <u>GCC 也有一个关键词 __thread</u>，可以放在基本类型前面，被它修饰的变量就成了线程局部变量，虽然只有一个，不同线程访问它时，实际上访问到的是不同的备份，如 Linux 的线程特定数据。

<br>

**map 和 unordered_map 相关问题**
> map 底层是一颗红黑树，每一个节点就是一个元素，元素内部有序。
> unordered_map 内部是一个哈希表，元素无序，冲突解决方式采用拉链法，插入元素时是头插法，当 hashtable 负载因子太大时会 rehash.
> 这两个都不是线程安全的。

<br>

**vector 相关问题**
> vector 支持下标范围检查，不过要使用 at() 接口，直接取下标不支持范围检查。
> vector 一般实现中采用 2 倍扩容，将原对象移动到新的容器中，平摊时间复杂度是 O(1)，但某一次的 push_back 时间复杂度可能是 O(n).
> 举个例子说明 push_back 和 emplace_back 的区别：
```C++
void foo() {
    vector<pair<int, int>> tmp;
    tmp.push_back({1, 2});
    tmp.push_back(pair<int, int>{1, 2});
    tmp.emplace_back(1, 2);
    tmp.emplace_back(pair<int, int>{1, 2});
}
```
> push_back() 需要先调用一次构造函数，构造临时变量，然后再调用一次拷贝构造函数，而 emplace_back() 只需要构造一次，所以直接传入构造函数的参数即可，当然 emplace_back 是可以直接传对象的，push_back 却不能只穿参数。


<br>


**拷贝构造函数与移动构造函数**
> 拷贝构造函数的形参是一个左值引用，拷贝构造函数完成的是整个对象或变量的拷贝；移动构造函数的形参是一个右值引用。
> 移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。

<br>

**智能指针用过哪些，讲讲特点**
> shared_ptr 该指针指向一个堆对象，并且会维护一个计数器（堆上，所有指向该对象的 shared_ptr 共享），当有一个新的 shared_ptr 指向这个对象时（通过拷贝复制、拷贝构造函数），他的计数器就会加一，当共享的 shared_ptr 析构时计数器会减一。当时最后一个指针调用析构函数的时候，就会释放该内存。
> unique_ptr 指针禁止对象的复制，如果出现了两个指针进行复制的情况，就会出现编译错误。但是可以使用move()函数来进行控制权限的转移。一般通过将拷贝复制函数和拷贝构造函数设为私有和删除的（=delete）。
> weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。 进行该对象的内存管理的是那个强引用的 shared_ptr，weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题,如果说两个 shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放，举个例子：
```C++
// 首先使用智能指针写一个双链表：
struct Node {
	int val;
	shared_ptr<Node> next;
	shared_ptr<Node> prev;
}

int main() {

	shared_ptr<Node> node1(new Node);
	shared_ptr<Node> node2(new Node);
	
	node1->next = node2;
	node2->prev = node1;
	
	return 0;
}

/*
分析引用计数：
    对于node1，初始化时，引用计数为1，执行node2->prev = node1语句后，
    调用赋值运算符，引用计数+1，变为2

    对于node2，初始化时，引用计数为1，执行node1->next = node2语句后，
    调用赋值运算符，引用计数+1，变为2

    所以当main结束时，虽然node1和node2生命周期结束，会被销毁，但其记录的引用计数不为1，所以并不会释放对象。

这种情况称为循环引用，使用 weak_ptr 解决。
*/

struct Node {
	int val;
	~Node() { cout << "free me" << endl; }
	weak_ptr<Node> next;
	weak_ptr<Node> prev;
};
```

<br>


**[C++ static](https://www.zhihu.com/search?type=content&q=C%2B%2B%20static%20)**
> 静态成员变量
> 静态成员函数
> 静态全局变量
> 静态局部变量
> 静态函数

<br>


### Golang 部分
**协程是什么，golang 协程怎么实现的**
> [协程参考文章](https://mp.weixin.qq.com/s/vUNLc9hzIi9EajCPOaEk_g)<br>



<br>

### 网络部分
**浏览器输入 url 的过程中，做哪些优化可以提升响应速度**
cookie 和 session
浏览器如何访问本地缓存
使用浏览器缓存可能会有什么问题

<br>



### 未分类部分
**针对多线程设计有没有什么心得?**
> * 如果不是必须，尽量少使用共享内存，共享内存中的同步很麻烦，如果线程崩了，共享内存很可能就无法再次使用。
> * 运行线程的数量一般不大于核心数，尽量提升并行度。
> * 如果变量支持原子操作，最好使用原子操作，不需要自己维护锁。
> * 如果锁持有的时间比较短，而又是多核处理器，可以考虑使用自旋锁。
> * 使用线程池，减少创建和销毁线程带来的开销。
> * 多线程问题不容易复现，做好日志记录，或采用一些工具，比如 pstack.


<br>

**如何修改 LRU 为线程安全的（尽可能保证性能）**

<br>

**如何实现无锁队列**
> [无锁队列的原理和实现](https://zhuanlan.zhihu.com/p/352723264) 
> [C++ 11 CAS 原子操作](https://blog.csdn.net/feikudai8460/article/details/107035480/) 

<br>

**设计模式知道哪些**
> [C++ 单例模式](https://zhuanlan.zhihu.com/p/37469260)
> [其他设计模式资源](https://www.zhihu.com/question/299975615/answer/2154388070)

<br>

**造成 HDD/SSD 顺序 IO 和随机 IO 性能差异的原因**
> [SSD 参考资料](https://www.zhihu.com/question/47544675/answer/670562224)<br>



<!-- ## 面试经验 -->

<!-- 
## 他人面经
### 星环科技-数据开发 -->
spark 和 mapreduce 区别
flink 和 spark 区别
统计一个小时内用户点击量 (flink 相关)
savepoint checkpoint (flink 相关)

两个线程对一个变量进行 ++ 怎么保证线程安全
> * 加锁 std::mutex
> * 原子类型 std::atomic<int>

MongoDB 和 Redis 以及 MySQL 的技术选型

Linux 中如何查找进程
> 在Linux 系统中 ps 和 top 命令都是用来查看进程信息的。ps 命令只看到的是命令执行瞬间的进程信息快照，而 top 是动态的；另外 top 还能操纵进程优先级等。




<br>

sleep(0) 的作用
> std::this_thread::yield() 放弃剩下的时间片，让其他就绪的线程运行，若没有其他就绪的线程，该函数立即返回。

<br>

进程间通信
> 消息队列
> 匿名/命名管道
> 信号量
> 信号
> 条件变量
> 共享内存



<br>

InnoDB 如何实现 MVCC
> [参考文章](https://zhuanlan.zhihu.com/p/40208895)

redolog 和 binlog 以及 undolog
> [参考上面数据库部分的 binlog](#数据库部分)

<br>

B 树和 B+ 树
> [参考上面数据库部分的 binlog](#数据库部分)

<br>

索引的种类你知道哪些
> * 从索引数据结构分类：B、B+、LSM、可拓展哈希
> * 从使用上分类：主索引、次级索引、覆盖索引、全局主索引、全局二级索引和联合索引
> [参考上面数据库部分的或其他文章](#数据库部分)

## Redis
> * [redis 的持久化（RDB，AOF）](https://zhuanlan.zhihu.com/p/106997927)
> * [跳表与红黑树的选择](https://www.zhihu.com/question/20202931/answer/14319325)
> * [介绍了跳表的数据结构和与红黑树的选择](https://zhuanlan.zhihu.com/p/23370124)
> * [redis 底层数据结构之字典](https://zhuanlan.zhihu.com/p/103367975)
> * [为什么要用 redis？redis为什么这么快](https://zhuanlan.zhihu.com/p/81195864)
> * [redis 综合面经：基本数据类型、缓存、雪崩等等](https://zhuanlan.zhihu.com/p/118561398)
> * redis 的事务：微信读书-redis 设计与实现
> * [redis 大 key 的影响](https://mp.weixin.qq.com/s/_vIYdzh3dA1kjw4IgMsnPA)
> * [redis 实现分布式锁](https://mp.weixin.qq.com/s/ESdfA5sJa6bmL-HvuWpoJA)
> * [redis 哨兵](https://mp.weixin.qq.com/s/DzVY4iA-_my0JUSqOOniOw)
> * [redis 缓存与数据库的一致性问题](https://mp.weixin.qq.com/s/DzVY4iA-_my0JUSqOOniOw)


## MySQL
> * [mysql 常见面试题-1](https://zhuanlan.zhihu.com/p/366840427)
> * [mysql 场景面试题-2](https://zhuanlan.zhihu.com/p/403656116)
> * [MySQL MVCC](https://zhuanlan.zhihu.com/p/66791480)
> * [mysql 常见面试题-3](https://www.zhihu.com/question/486105337/answer/2269843039)
> * [B 树的单条查询性能与 B+ 树比如何](https://zhuanlan.zhihu.com/p/107228878)

<br>

## 网络部分
> * [IO 多路复用](https://zhuanlan.zhihu.com/p/358208161)
> * [epoll 详解](https://zhuanlan.zhihu.com/p/63179839)
> * [参考计算机网络八股文](https://zhuanlan.zhihu.com/p/366839763)
> * [HTTP 与 HTTPS 的区别](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)
> * [浏览器如何验证HTTPS证书的合法性?](https://www.zhihu.com/question/37370216/answer/1914075935)
> * [Reactor & Proactor](https://mp.weixin.qq.com/s/GRkZ1IEfTalQSkErWe1SAg)


## 操作系统
> **虚拟内存**
> * 虚拟内存可以参考现代操作系统第三章
> * [huge page](https://zhuanlan.zhihu.com/p/34659353)
> * [页面置换算法](https://mp.weixin.qq.com/s/RcaACHpO6KZDycAIm_dNMA)
>> 另外在数据库缓冲池中还有一个叫做 LIRS 的算法：
>> LRU 算法在大多数情况下表现是不错的，但有一个问题：假如某一个查询做了一次全表扫描，将导致缓冲池中的大量页面（可能包含很多很快被访问的热点页面）被替换，从而污染缓冲池。现代数据库一般采用 LIRS 算法，将缓冲池分为两级，数据首先进入第一级，如果数据在较短的时间内被访问两次或者以上，则成为热点数据进入第二级，每一级内部还是采用 LRU 替换算法。Oracle 数据库中的 Touch Count 算法和 MySQL InnoDB 中的替换算法都采用了类似的分级思想。以 MySQL InnoDB 为例，InnoDB 内部的 LRU 链表分为两部分：新子链表（new sublist）和老子链表（old sublist），默认情况下，前者占 5/8，后者占 3/8。页面首先插入到老子链表，InnoDB 要求页面在老子链表停留时间超过一定值，比如 1 秒，才有可能被转移到新子链表。当出现全表扫描时，InnoDB 将数据页面载入到老子链表，由于数据页面在老子链表中的停留时间不够，不会被转移到新子链表中，这就避免了新子链表中的页面被替换出去的情况。

<br>

> * [零拷贝：原理、优点、缺点](https://blog.csdn.net/mseaspring/article/details/106346264)
> * [Linux 之模拟 CPU 占用率过高故障排查](https://www.cnblogs.com/biaopei/p/11523711.html)
> * [Linux 问题排查 I/O 篇](https://www.freesion.com/article/2720655745/)

<br>

> **进程/线程**
> * [进程调度的几种算法](https://blog.csdn.net/weixin_43916755/article/details/124440247)
> * Linux 进程调度，可以参考 Linux 环境编程：从应用到内核
> * [死锁简介](https://zhuanlan.zhihu.com/p/26945588)
> * [死锁-银行家算法](https://www.cnblogs.com/MrLiuZF/p/15186204.html)
> * [死锁-哲学家进餐](https://blog.csdn.net/weixin_43036882/article/details/106967572)




## Go 语言
> * [Garbage Collection In Go](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html)
> * [垃圾收集器原理（还有许多精彩的内容）](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)
> * [golang 面试题](https://zhuanlan.zhihu.com/p/519979757)



## 场景题
> * [高并发系统设计](https://www.zhihu.com/question/421237964/answer/1699066805)
> * [海量数据处理-1](https://www.nowcoder.com/discuss/1018657?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1662730394395)
> * [海量数据处理-2](https://www.nowcoder.com/discuss/972028?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1662730394395)
> * [海量数据处理-3](https://www.nowcoder.com/discuss/981536?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack)
> * [海量数据处理-4](https://www.nowcoder.com/discuss/980548?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1662730809118)
> * [智力题-1](https://www.nowcoder.com/discuss/150434?type=all&order=recall&pos=&page=3&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1662730915715)
> * [智力题-2](https://www.nowcoder.com/discuss/980265?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1662731015077)
> * [智力题-3](https://www.nowcoder.com/discuss/724104?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1662731090769)
> * [智力题-4](https://www.nowcoder.com/discuss/188535?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1662731310793)
> * [别人总结的](https://www.nowcoder.com/discuss/428774?type=post&order=recall&pos=&page=3&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1662731403307)
> * [还可以看看 CodeTop 里面的](https://codetop.cc/discuss/algo?tags=&page=3&type=read_num)

## C++ 部分
> * [60 道必问 C++ 题目](https://zhuanlan.zhihu.com/p/470972286)
> * [C++ 11 新特性系列](https://www.zhihu.com/question/65209863/answer/1957019832)
> * [移动构造函数](https://avdancedu.com/a39d51f9/)
> * [C++ 完美转发](https://zhuanlan.zhihu.com/p/99524127)


## 系统设计部分
> * [如何设计一个秒杀系统](https://zhuanlan.zhihu.com/p/109742840)


## TiDB 系列
> * [TiDB 基于规则的优化](https://cn.pingcap.com/blog/tidb-source-code-reading-7)
> * [TiDB 基于规则的优化 II](https://cn.pingcap.com/blog/tidb-source-code-reading-21)
> * [TiDB 基于代价的优化](https://cn.pingcap.com/blog/tidb-source-code-reading-8)
> * [TiDB 的 SQL Parser 实现](https://cn.pingcap.com/blog/tidb-source-code-reading-5)
> * [TiDB 的 Hash Join 的实现](https://cn.pingcap.com/blog/tidb-source-code-reading-9)
> * [TiDB 的 Index Lookup Join](https://cn.pingcap.com/blog/tidb-source-code-reading-11)
> * [TiDB 的 Sort Merge Join](https://cn.pingcap.com/blog/tidb-source-code-reading-15)
> * [TiDB Insert 语句详解 I](https://cn.pingcap.com/blog/tidb-source-code-reading-4)
> * [TiDB Insert 语句详解 II](https://cn.pingcap.com/blog/tidb-source-code-reading-16)
> * [TiDB 的 Table Partition](https://cn.pingcap.com/blog/tidb-source-code-reading-20)
> * [TiDB 的 Hash Aggregation](https://cn.pingcap.com/blog/tidb-source-code-reading-22)


<br>

一致性 Hash 中的数据倾斜
> {% post_link 一致性哈希 %} <br>

<br>

2G 内存，10G 的数据，如何从 10GB 的数据中获得只出现过一次的数据
> [bitmap 的使用](https://www.nowcoder.com/discuss/972028?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=D68E102664C380A9CA158174513A3880-1660376906461)
> 

<br>

怎么实现 main 线程阻塞，其他线程处理，结束后返回主线程继续执行
> 主要是线程同步的问题

<br>

数据库：Mysql，如果查询慢了怎么做：看查询关键字使用，如果经常使用就加索引。
加了索引查询时间区别不大，怎么处理：那肯定就数据量太大了，分库或者分表
什么是火山模型，你是怎么实现的，火山模型有什么优缺点
> [参考文章](https://zhuanlan.zhihu.com/p/219516250)。一句话简答：火山模型是将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶子结点自上而下地递归调用 next() 函数。其主要缺点在于每次迭代只会涉及到一条记录，对 CPU 的利用率不高（频繁的函数调用）。优化方法一般有两种：① next() 函数返回一批记录；② 该 Operator 树自底向上推送记录，也就是采用 pipeline 的方式，每个 Operator 之间有一个缓冲区，各个 Operator 并发地执行，当写缓冲满了或读缓冲空了就等待，否则就一直向上推送记录，具体见{% post_link "查询处理篇：查询执行模型" 文章 %}。

<br>

各种 Join 算法的优缺点和实现方式
> 还没总结，先参考这篇[文章](https://zhuanlan.zhihu.com/p/91510137)。一句话总结：Hash Join 适合至少有一个小表的场景，因为我们希望 build 阶段尽可能的将 hash 索引放在内存；如果两张表都很大，那么就可以采用 merge join 算法。

<br>

什么是可扩展哈希算法，具体讲讲
三个隔离级别分别怎么实现，加锁策略是什么
什么是两阶段锁
锁是怎么管理的，一个事务请求锁的具体过程讲讲
什么是一致性哈希算法、数据倾斜怎么解决
shared_ptr 原理
智能指针的优缺点
[力扣-搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
你当我对 raft 一点都不了解，给我介绍一下 raft 是什么，在你的项目中起了什么样的作用
如果一个 Follower 缺了一些日志怎么发现
raft 选举流程说一下
你在 raft 上做了或者了解哪些优化
mysql 的索引怎么做的、mysql 的锁怎么做的
[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
分析型数据库的计算方向，还说了一些我不懂的列存储、弱事务啥的


## 我的缺点
> **第一个缺点的话**，我觉得是作为一个学生思维上的局限性，很多时候都认为事情有唯一标准的答案，如果没有确切的把握就害怕表达自己的看法，总是会在脑袋里尝试证明一下。很久以前我就意识到这个问题，因为一直在学校也就没有带来多大的负面影响，最近参加了一些公司的面试，这个缺点就被放大了。在回答面试官的问题时总是尝试想到问题的方方面面，尽可能地无懈可击，所以回答一些问题时我会花费较多时间思考，想得太多而短时间内又没能很好地组织，所以表现出来给人的感觉就是比较混乱。
> 
> 目前正在学习一些层次化和结构化的表达方式来改善这一点。


> **第二个缺点的话**，是性格上还是有些腼腆，在公开场合讲话、发表意见会感到很紧张。正是因为这个原因，我会在讲话前做充分的准备，尽可能流畅地阐述清楚自己的观点。


> **第三个缺点的话**，有一点爱钻牛角尖，这应该和我是工科有关系，喜欢将某一个问题探究到底，如果有一点不懂的话就会感觉不畅快。

## 我的优点
> **第一个优点**是比较有行动力，基本上我想做一件事，我会先思考可行性、然后制定详细的计划慢慢的去执行。比如我高中时想看看自己的体力极限在哪，所以我计划放暑假后不坐车，而是跑步回家。高中学校离家大概 50 多公里，为了这个计划，我提前三个月练习跑步，最后边跑边走花了 8 个多小时才到家。


## 学习方法
> 如果对我来说完全是新的东西，那我一般有三个步骤：第一步是收集资料，在这一步我会利用搜索引擎、教材等等尽可能地找到与之相关地东西。第二步就是集中阅读上一步收集地资料，这一步话的时间最多，可能需要反复阅读，做一些思维导图、笔记之类的。第三步就是在第二步的基础上找一些重要的点继续深入，或者整理一些问题向其他人咨询。这其实就是科研的一般步骤，能够快速的让你了解一个领域或方向的大概和重要的内容。

> 我还有一个习惯，如果我理解不了某个概念，我会先记住它然后找一些应用看看，如果还是理解不了，我就会去找这个概念的多个版本对比着看，如果还是不行，就把疑问整理下问问其他人，和其他讨论下。


## 问面试官的问题
> * 如果我有幸入职，对于这个岗位，您对我3-5年职业规划的建议是什么呢？
> * 就刚才的面试表现，能给一些意见吗，有哪些地方是需要加强的？
> * 这个职位的具体岗位职责是什么？
> * 公司对我这个职位的期望是什么？
> * 团队成员有多少人？核心工作有哪些？
> * 这个职位需要为团队（或者公司）创造什么样的价值？
> * 如果有幸被录用，那么入职后最重要的三件事（三个任务）是什么？
> * 能不能具体介绍一下我面试的这个部门的一个整体情况？
> * 未来3-5年的公司战略是什么？
> * 贵公司对新入公司的员工有没有什么培养计划？

## CEO 面要准备的东西
### 技术相关
> * 多版本并发控制
> * Percolator
> * Raft
> * B+、LSM 等存储结构

### 开放问题
> * 为什么想要从事数据库内核这一职业？
> * 是如何知道本公司的？
> * 如何看待数据库的发展前景？
> * 个人的职业规划？

### 有什么问题？
> * 未来3-5年的公司战略是什么？
> * 公司对我这个职位的期望是什么？
> * 如果我有幸入职，对于这个岗位，您对我3-5年职业规划的建议是什么呢？
> * 介绍一下团队情况：氛围、构成等等


## 国内数据库公司信息
### PingCAP
> 成立于 2015 年
> 产品：TiDB
> 产品定位：云原生的分布式数据库（HTAP）

### 星环科技
> 成立于 2013 年
> 产品：（太多了，随便选几个）分布式图数据库-StellarDB；分布式时序数据库-TimeLyre；分布式分析型数据库-ArgoDB；
> 公司定位：星环科技致力于打造企业级大数据基础软件。

### 武汉达梦
> 成立于 2000 年
> 产品：