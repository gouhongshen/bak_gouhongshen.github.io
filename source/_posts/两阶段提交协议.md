---
title: 事务篇五：两阶段提交协议
date: 2022-06-25 11:46:28
tags:
- 分布式事务
categories:
- [事务]
- [分布式]
math: true
sticky: 1
---

## 前言
这一篇文章主要是介绍如何在分布式数据库中保证事务的原子性和数据库的一致性。<font color=red>注意，两阶段提交协议只是用于协调在多个节点执行的事务（同一个事务被分成了多个子事务，并执行在多个节点上）的提交过程，并没有限制各个子事务在本地执行时使用的并发协议</font>。为方便叙述，给出一个分布式数据库的简化模型。
![系统架构](/img/two-phase-commit/1.jpg)
其中 TC 表示 transaction coordinator，负责协调在本地节点发起的本地或全局事务（若是全局事务，则会将其分成若干个子事务并分发给其他节点）。 TM 表示 transaction manager，负责本地或全局（子）事务在本地节点的执行（包括数据访问、锁等）。

## 两阶段提交协议（Two-phase Commit Protocol）
<font color=dark-green>协议执行步骤</font>
假设节点 $N_i$ 的协调器 $C_i$ 发起了一个全局事务 T，当 $C_i$ 收到了**所有**执行 T （子）事务的节点的消息 —— **T 已经执行完成，$C_i$ 开始 2PC 协议**：
* <u>第一个阶段</u>。$C_i$ 向 log 文件中追加一条 \<prepare T\> 记录并将其 *output* 到 stable storage。 然后，它发送一条 prepare T 消息给所有执行事务 T 的节点。当某个节点收到该消息后，它的 TM 将决定是否提交事务 T（在该节点执行的部分）。若不同意提交，该节点追加一条 \<no T\> 记录到 log 文件中，并回复一条 abort T 消息 给 $C_i$. 若同意提交，该节点追加一条 \<ready T\> 记录到 log 文件中，并将其 *output* 到 stable storage 中，然后回复一条 ready T 消息到 $C_i$.
* <u>第二个阶段</u>。只有当 $C_i$ 收到来自所有节点的 ready T 消息后，T 才能被提交，否则事务 T 必须被中止。如果 $C_i$ 收到了所有的 ready T 消息，它向 log 文件追加一条 \<commit T\> 记录，否则追加一条 \<abort T\> 记录，并将记录 *output* 到 stable storage 中。取决于上一步操作， $C_i$ 将发送一条 commit T 或者 abort T 消息给所有参与的节点，当其他节点收到该条消息后，追加 \<commit T\> 或 \<abort T\> 记录到 log 中，并执行相应的提交或中止操作。

下图展示了，三个节点共同参与事务，并同意提交的情况：
![系统架构](/img/two-phase-commit/2.jpg)

<font color=dark-green>协议的一些细节</font>
为防止参与者故障离线，协调器 $C_i$ 会在发送 prepare 消息后开启一个定时器，如果定时器超时后还存在没有回复的节点，那么 $C_i$ 就可以决定中止该事务，并发送 abort T 消息给所有节点。

在执行两阶段提交协议时，任一一个参与者，可以在发送 ready T 消息之前无条件的中止事务，一旦节点将 \<ready T\> 追加到日志文件中，事务在该节点就处于 ready state. **事实上， ready T 消息是一个承诺：**该节点对事务的处理将完全按照协调器 $C_i$ 的指令。节点为了在故障恢复后已经信守承诺，所以将必要的日志记录到 stable storage 中。而且，事务所获取到的锁也必须持有直到事务结束。需要注意，协调器所在的节点也会执行事务的一部分，因此 $C_i$ 可以单方面的决定事务的提交还是中止，尽管它收到了所有节点的 ready T 消息。

当事务的命运被决定后，协调器会发送 commit T 或者 abort T 消息给所有参与的节点，为防止节点未收到该消息，**一些实现中会增加一个步骤：**协调器发送完消息后，会等待节点回复 acknowledge T 消息，当收到所有回复后，协调器追加一条 \<complete T\> 到日志中。该步骤未完成前，协调器需要记录对事务的决定，因为可能一些未收到消息的节点会询问，该步骤完成后，即可丢弃该事务的信息。

## 协议中的故障处理
假设某次全局事务 T 的发起节点为 $N_i$，协调器为 $C_i$.

<font color=dark-green>非协调器节点 $N_k$ 故障离线</font>
事务两阶段提交协议执行中，协调器 $C_i$ 检测到节点 $N_k$ 发生故障，会做出如下反应：
* 如果故障发生在协调器收到 ready T 消息之前，$C_i$ 会假定 $N_k$ 拒绝提交该事务。
* 如果故障发生在协调器收到 ready T 消息之后，$C_i$ 走正常流程，忽视故障。

当该故障节点 $N_k$ 重新上线后，该节点会检查 log 文件进入恢复流程（详见{% post_link 数据库恢复系统 %}），假设事务 T 存在于日志文件中：
* 如果日志包含了 \<commit T\> 记录，$N_k$ 对事务 T 执行 redo 操作。
* 如果日志包含了 \<abort T\> 记录，$N_k$ 对事务 T 执行 undo 操作。
* 如果日志只包含了 \<ready T\> 记录，说明节点故障发生在节点做出承诺之后，事务的后续结果如何无从得知，所以该种情况下，节点必须询问协调器 $C_i$. <u>如果协调器在线</u>，会将结果回复给 $N_k$，该节点根据回复的结果执行 redo 或 undo；<u>如果协调器故障离线</u>，$N_k$ 会向系统中的所有节点询问，收到该询问的节点会查询 log 文件，若有相关的记录则回复，否则忽略，如果没有任何节点能告知 $N_k$，则 $N_k$ 必须周期地发送询问给所有节点直到有答案产生（$C_i$ 必然有相关的记录）。
* 如果日志中不包含任何关于 T 的记录，即 abort、commit、ready 都没有，那么可以肯定，$N_k$ 在回复 prepare T 消息之前就发生故障了。结合协调器 $C_i$ 对该种情况的处理，$N_k$ 必须对事务 T 执行 undo. 

<br>

<font color=dark-green>协调器节点 $C_i$ 故障离线</font>
如果协调器 $C_i$ 在执行提交协议过程中故障离线，剩下的节点就必须决定事务 T 的命运，可能存在以下可能：
* 如果某个节点包含了 \<commit T\> 记录，事务 T 必须提交。
* 如果某个节点包含了 \<abort T\> 记录，事务 T 必须中止。
* 如果存在节点不包含 \<ready T\> 记录（还未回复/收到 prepare T 消息），说明这种局势下，就算 $C_i$ 没有发生故障，也不能决定事务的提交与否。比起等待 $C_i$ 恢复，中止 T 更有好处（因为不确定的因素太多）。
* 如果上面情况都不满足，说明所有的节点都包含 \<ready T\> 记录，但是没有额外的记录（即 commit 或 abort）。这种情况 $C_i$ 既有可能已经决定了事务 T 的命运，也可能没有，<font color=red>因此必须要等待协调器 $C_i$ 恢复</font>。

<br>

<font color=dark-green>网络分区故障（Network Partition）</font>
网络分区故障是指，整个分布式系统因为网络连接问题被划分成了几个子系统（partitioned），这几个子系统互相之间没有网络连接。单个子系统中可能存在多个节点，也可能只存在一个节点。

提交协议执行中，当网络分区故障发生后，有如下两种可能：
* 协调器 $C_i$ 和其他参与者仍旧处于同一个分区，该种情况下，网络分区故障对该次提交协议没有任何影响。
* 协调器 $C_i$ 和其他参与者属于多个分区。不妨假设两个分区，第一个分区包含协调器和部分参与者，第二个分区包含其他参与者。第一个分区内的处理方式和正常情况下处理非协调器故障离线方式一样；第二个分区内的处理方式和正常情况下处理协调器故障离线的方式一样。

## 2PC 协议存在的问题

协调器的失败可能使得某个事务处于模糊状态（remain in doubt）。这段时间内（hours or days），事务需要持持有系统的资源，比如事务持有某些数据的排它锁，在参与该事务提交的节点上，其他新的事务就可能必须等待。因此数据不仅在失败的节点上不可用，而且在活跃的节点上也变得不可用。

由以上内容可知，<font color=red>2PC 协议最大的缺点是，可能导致多个节点阻塞（blocking），即对某个事务的决策（提交或者中止）需要推迟到协调器重新上线。</font>

另外，引入分布式提交后，故障节点重启后的恢复过程也有些不一样了。这些不一样体现在恢复算法（见{% post_link 数据库恢复系统 %}）对待处于不确定状态的事务，即对于该事务，存在 \<ready T\> 记录在 log 文件中，但不存在 \<commit T\> 或 \<abort T\> 记录，因此该节点必须询问其他节点后才能决定该事务提交与否。<font color=red>要知道询问过程可能维持很长一段时间，这段时间内该节点将变得不可用。</font>为了避免该问题，节点收到来自协调器的 prepare T 消息并同意提交后，不再记录 \<ready T\>，而是 \<ready T, L\> 到日志文件中，L 表示该事务持有的排它锁。等到重启恢复时，如果存在状态不确定的分布式事务，节点便重新获取这些锁，然后就可以开始正常的其他事务处理了，不需要再等待那些不确定状态的分布式事务，但需要注意，与这些排它锁冲突的事务依然需要等待。

## 2PC 协议问题的解决
<font color=dark-green>解决方案一：共识算法</font>
通过上面的讨论，分布式事务的提交决议过程不能避免等待，问题出在等待的时长。如果协调器故障离线，那么这样的阻塞等待可能持续数小时或数天，使得大规模的节点不可用。在{% post_link raft-杂记 %}一文中介绍的共识算法就可以用来处理协调器（可以理解为leader）失效的情况。只要大部分的参与者可用，那么等待时间就不会太长。

采用共识算法处理 2PC blocking 问题的建议早在 1980s 就已经提出了，在 Google Spanner 分布式数据库系统中就采用了该算法。


<br>

<font color=dark-green>解决方案二：3PC 协议</font>
[见博客](https://blog.csdn.net/qq_31960623/article/details/116429261)


<br>

<font color=dark-green>解决方案三：Persistent Messaging</font>
未完待续