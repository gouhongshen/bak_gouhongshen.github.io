---
title: 事务篇一：事务总论
date: 2022-06-22 10:34:31
tags:
 - 数据库
 - 事务
categories:
 - [数据库]
 - [事务]

sticky: 999
---


## 前言
本文内容来自 database system concepts 第七版第十七章，主要是大概介绍事务的基本概念。更进一步的内容会引用其他文章，所以该文相当于一篇索引。

**单机事务部分（local transactions）：**
{% post_link 事务的可串行化 %} <br /> 
{% post_link 事务的并发控制 %} <br />
{% post_link 数据库恢复系统 %} <br />

<br />

**分布式事务部分（global transactions）：**
{% post_link 两阶段提交协议 %} <br />
{% post_link Percolator-随笔 %} <br />

<br />

<font color=red>分布式事务部分和单机事务部分的不同主要在于如何在多个节点保证事务的原子性。</font>


## Transaction Basic Concept
事务是一个逻辑单元，它包含了一组操作，这些操作可能访问或修改不同的数据。对用户来说，这组操作（事务）是一个单一的、不可分割的部分（比如，用户发起转账请求，这个请求对用户来说单一的操作，而在实际执行时分为多个步骤：安全性检查、出账、入账等），也就是说事务要么完成（其包含的所有步骤全部执行完成）或者失败（所有步骤皆失败），这个 all-or-none 特性被称为<font color=red>原子性（atomicity）</font>。

因为事务是一个不可分割的单元，所以它内含的步骤不能被数据库的其他操作分隔开。即使多个事务并发（concurrence），数据库系统也需要保证如此，即对于每两个事务 TA，TB，TA 要么开始于 TB 结束之后，要么结束于 TB 开始之前。这个特性被称为<font color=red>隔离性（isolation）</font>，后面会发现隔离性主要讲的是各个事务互相影响的程度，不同的隔离程度有不同的现象。

当事务执行完成提交后，它对数据库的修改不会丢失，即使系统从崩溃中恢复。这个特性被称为<font color=red>持久性（durability）</font>。

另外，事务还需要保证数据库的<font color=red>一致性（consistency）</font>，即，事务将系统从一个正确的状态迁移到另一个正确的状态，正确的状态是指数据库当前的状态满足预定的约束。约束可能由数据库底层提供（比如插入新数据时需要满足主键唯一约束）也可能来自上层应用（比如出账与入账要平衡），所以一致性的要求无法完全由数据库系统本身保证，它可能与上层逻辑有关。

以上四个特性被简称位 ACID，其中 AID 都为 C 服务。


## Storage Structure
这里需要清楚一些存储的概念，比如易失性存储（volatile storage）、非易失性存储（non-volatile storage）、稳定性存储（stable storage）。

**主要是 stable storage 的概念**：只要数据写入 stable storage，那么它们就“永远”不可能丢失，要实现这样的存储，需要将数据备份（replicate）到多个非易失性存储介质上，这些非易失性存储分别独立，有自己的错误处理模块。{% post_link raft-杂记 关于多从节点如何安全的备份，参考分布式一致性协议 raft %}。

## Transaction Atomicity and Durability
**需要明白，原子性的挑战在哪里？**

事务并不总是成功执行。结束的事务（terminated txn）有两种可能：
* committed，事务成功完成了所有操作，所有更新都已经写入了数据库；
* aborted，事务因各种原因失败，事务造成的修改都已经恢复（rolled back），数据库回到了事务开始之前的状态。

对失败的事务造成的修改如何恢复，是保证原子性的一个难点。通常采用日志的方式实现（事务对数据库的每一个修改都先写入日志中），维护日志不仅可以重新事务的修改操作（保证原子性和持久性），还能在事务失败后撤销修改，以保证原子性。数据库的 recovery system 负责保证原子性和持久性，{% post_link 数据库恢复系统 参见文章：数据库恢复系统 %}。

对于，原子性和持久化还有一个部分需要注意：外部可见更新（observable external writes），如更新显示到屏幕、发送邮件或者网上购物等场景。如果事务半途中断，这些更新难以撤回。一般的解决方法是，先将更新存储到数据库的某个地方，等到事务提交后，在将这些更新应用到外部，另外，如果系统在事务提交后，应用更新到外部之前崩溃，那么等到系统重启后依然可以应用更新到外部。

## Transaction Isolation
SQL 标准将隔离级别（isolation level）分为四类：

**可串行化-serializable**，即事务之间的执行顺序可串行化，其结果等价于串行执行，能够保证数据库的一致性。该隔离级别允许一定程度的并发，属于最高的隔离级别。一般，数据库为了提升性能，实现时不会完全遵循其标准。关于串行化的定义，可以参见文章：{% post_link 事务的可串行化 事务的串行化定义 %}。

**可重复读-repeatable read**，该级别规定了两点：1）只读已经提交了的数据；2）在事务执行期间多次读取一个数据的时间内，不允许其他任何事务更新该数据。该隔离级别保证了在<u>一个事务中，多次读取同一个数据总会得到同样的值</u>。但注意，这里只是规定了不允许更新已存在的数据，对于其他事务插入新的数据却未做规定，这就导致了，遵循该级别的事务在两次读取中，有可能第二次读取的数据中有一些不存在于第一次读取中的新数据（共同拥有的数据还是相同的），即幻读，若使用快照隔离提供稳定的视图，则不会出现幻读。

**读已提交-read committed**，该级别比上一级别更弱，由上一级别的叙述可知，遵循该级别的事务在两次读取同一数据，这两次的数据可能不同，因为其他事务在这段时间内更新了该数据，即不可重复读。

**读未提交-read uncommitted**，这是最低的级别了，该级别甚至允许一个事务读取另外一个事务的中间结果，即脏读。

解释下读已提交/未提交中的提交的含义：提交是指事务的提交。假设有两个事务： TA 读取数据 S，TB 修改数据 S。读未提交允许 TA 读取被 TB 修改了的数据 S，尽管 TB 还未提交。这里存在的可能隐患是，若 TB 失败终止了，所有修改都会回滚，也就是说，TA 读取到了无效的值。

区分下幻读和不可重复读现象的区别：幻读是指，本次读出的数据中，有一部分在之前读取的结果中不存在，幻读存在于范围读取中；不可重复读是指，本次读出的数据和之前的值不相等。

总结下，各种隔离级别可能发生的<font color=red>现象</font>：
|        |脏读|幻读|不可重复读|脏写|
|:-:    |:-: |:-: |:-:      |:-: |
|可串行化|禁止|禁止|      禁止|禁止|
|可重复读|禁止|？|      禁止|禁止|
|读已提交|禁止|允许|      允许|禁止|
|读未提交|允许|允许|      允许|禁止|


## Implementation of Isolation Level
该部分内容广且复杂，在文章 {% post_link 事务的并发控制 事务的并发控制中有详细介绍。%}



