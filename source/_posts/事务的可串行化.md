---
title: 事务篇二：事务的可串行化
date: 2022-06-22 16:26:22
tags:
- 事务
categories:
- [事务]
sticky: 1
---

## 前言
该文章的内容来自 database system concepts 17.5-7，建议先看文章：{% post_link 事务总论 %}

为什么会有事务的串行化？因为数据库系统会允许事务的并发（concurrency），事务并发有如下两个优点：
**提升吞吐量和资源利用率**。事务通常包含多个操作（步骤），一些操作需要更多的 CPU 计算，而另外一些需要更多的 I/O. CPU 和 I/O 设备通常可以并行（parallel），如果同时允许多个事务并发，能减少 CPU 和 I/O 的空闲时间，那么可以提升吞吐量和资源利用率。

**减少等待时间**。如果所有事务只能串行，那么短事务只能等待长事务结束才能执行。如果事务能够并发，则能在一定程度上共享 CPU 和磁盘资源，减少响应时间。

**并发很有好处，但它可能会破坏事务的隔离性，破坏数据的一致性**。因此有必要研究各个并发的事务需要满足什么关系，才能保证隔离性和数据库的一致性。并发的具体实现方案，参见文章：{% post_link 事务的并发控制 %}。

## Schedules
**考虑一个例子**：有 A 和 B 两个账户，其初始值分别为 1000 和 2000，事务 T1 从账户 A 转账 50 到账户 B，而事务 T2 从账户 A 转账 10% 到账户 B。这两个事务包含许多指令（instructions），当它们并发时，这些指令可能以各种顺序执行（但属于同一个事务的的各指令间相对顺序一定，而属于不同事务的指令间顺序可能变化），这样具体的一个顺序称为一个调度（schedule），如下面的调度1和调度2
![schedule 1](/img/schedule-serializable/schedule1.jpg) 
![schedule 2](/img/schedule-serializable/schedule2.jpg)

**串行调度（serial schedule）**：在调度中，属于同一个事务的指令出现在一起。如 schedule 1 是串行的调度，而 schedule 2 不是。对于 n 个事务，可以组成最多 n! 个不同的串行调度。

很明显，串行的调度方案一定能保证隔离性和一致性，但在并发时，不同事务的指令可能交叉，调度并不总是串行的，但如果能保证一个调度方案对数据库的修改与某个串行调度方案的修改结果一致，那么该调度方案就保证了一致性，如上图调度1执行后，A+B=3000，调度2执行后，A+B=3000，这样的调度等价于串行调度，被称为**可串行化调度（serializable schedule）**。


## Conflict Serializability 
但我们不能将并发事务的调度方案执行后，根据结果来判断这样的并发是否能保证数据库的一致性。需要采取其他办法判断。

这里先介绍冲突可串行化（conflict serializability）的概念。

冲突的定义为：假设，指令 I 和 J 属于不同的事务且对相同的数据执行操作，当 I 和 J 之中至少有一个是修改操作（write）时，I，J 冲突。

对于非冲突的指令，我们可以交换它们的顺序而不会影响调度最终的结果（如交换调度2中 T1 的 read(B) 和 T2 的 write(A)），而对于冲突的指令，交换它们则会产生影响。如果一个调度方案 S1 能够通过交换一系列不冲突指令后，变成调度方案 S2，那么 S1 和 S2 冲突等价（conflict equivalent），如果 S2 恰好是一个串行调度方案，那么 S1 就可以称为**冲突可串行化**（与串行调度冲突等价）。

由上可知，如果一个调度方案冲突可串行化，那么它能保证数据的一致性，现在问题是如何判断一个调度是否冲突可串行化？构造**先行图（precedence graph）**后可以很容易的判断。

先行图是一个有向图，其顶点表示并发的事务，假设在一个调度方案 S 中有 TA 和 TB 两个并发事务，Q 表示某个数据。当且仅当以下任何一种情况发生时，TA 到 TB 有一条边 （TA -> TB）：
* TA 执行 write(Q) 之后 TB 会执行 read(Q)
* TA 执行 read(Q) 之后 TB 会执行 write(Q)
* TA 执行 write(Q) 之后 TB 会执行 write(Q)

如果边 TA -> TB 存在，那么在任何与 S 等价的串行调度方案中，TA 都要先于 TB 执行。

**假如某个调度方案的先行图含有环，那么，该调度就不是冲突可串行化的，若没有环，则该调度是冲突可串行化的**。

<font color=red>调度可串行化就万事大吉了吗？</font>上面讨论的内容都没有提到事务失败的情况，见下图：
![schedule 3](/img/schedule-serializable/schedule3.jpg)

很明显，调度3是冲突可串行化的。如果 T6 执行完 read(B) 后提交前失败了，按照原子性定义，T6 需要回滚，需要注意，T7 读取的数据正是 T6 更新的数据，而 T6 回滚时，T7 已经提交了。

一个允许事务并发的系统，为保证原子性，若一个事务失败了，依赖于这个事务的其他事务（即这些事务读取了失败事务所做的更新）都需要失败终止和回滚。在调度3中，T7 依赖于 T6，所以 T7 也需要回滚，但已经不可能了。

像调度3这样的调度方案属于不可恢复调度（nonrecoverable schedule）。

**可恢复调度（recoverable schedule）**是指，在一个调度中，对于任一两个事务 TA, TB，若 TA 读取了 TB 所做的更新，那么 TB 的提交操作必须出现在 TA 的提交操作之前。若 T7 的提交操作延迟到 T6 提交之后，那么调度3就是可恢复的。

为了提升性能，还需要介绍一种调度：cascadeless schedule (不知道怎么翻译，暂译作非失败连锁式调度)

考虑下面调度4的情况：
![schedule 4](/img/schedule-serializable/schedule4.jpg)

调度4中，T9 依赖 T8，T10 依赖 T9，若 T8 失败终止，那么 T9 和 T10 都需要失败终止。调度4同时满足冲突可串行化和可恢复，但单个事务的失败引起太多的事务失败，这显然会降低系统的性能，这样的调度被称为失败连锁式调度（cascade schedule）。

这里给出 **cascadeless schedule 的定义**：在一个调度中，对于任一两个事务 TA, TB，若 TA 读取了 TB 所做的更新，那么 TB 的提交操作必须出现在 TA 的**读**操作之前，显然，所有的 cascadeless 调度都是可恢复的。

## 总结
为了保证事务并发执行和单个按次序执行之间结果的一致性，提出了可串行化调度的定义。为了更加容易判断一个调度是否可串行化，引出了冲突可串行化的定义。可串行化调度能保证事务都成功执行后的一致性，但未能保证事务失败后的原子性，为了保证原子性，提出了可恢复调度的概念。再进一步，为了减少事务失败所引起的回滚操作，在可恢复之上再做限定，给出了 cascadeless 调度的定义。

按照隔离性的定义，<u>事务并发在一定程度上会破坏事务的隔离性</u>，因为属于不同事务的指令会可能交叉执行。ACID 的本质是什么？目的只有一个，那就是把活干了的同时要保证数据库的状态是确定的、正确的，说白了，AID 都是在为 C 服务。

<u>冲突可串行化在干什么？</u>它其实是给出了一种方法（先行图），这种方法从执行结果上来看是否与串行化执行一致（满足隔离性），只要结果与串行化一致，那就和满足了隔离性是等价的。

<u>可恢复调度又在干嘛？</u>它其实是让并发时，事务也能满足原子性。

这里没有涉及到 D.

在文章 {% post_link 事务的并发控制 %}，会介绍采取何种方法，能生成满足这些定义的调度方案。


