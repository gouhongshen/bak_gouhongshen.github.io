---
title: 事务篇三：事务的并发控制
date: 2022-06-22 16:29:21
tags:
- 事务
- mvcc
- snapshot
- two-phase-locking
categories:
- [事务]
sticky: 1
---

## 前言
在{% post_link 事务总论 %}中介绍了事务基本概念和具有特性，在{% post_link 事务的可串行化 %}中介绍了调度要具备何种性质，才能在并发事务执行后使系统处于一致性状态和事务失败后能让系统回到安全状态，还论证了隔离性与一致性的关系。

**并发控制的工作就是，在事务并发时，确保只会产生具备这种性质的调度方案**，具体地，并发控制策略的目标是同时保证两点：
* 使系统具有较高的事务并发度
* 确保生成的调度方案，同时是冲突可串行化（conflict serializable），可恢复（recoverable）和非失败连锁式（cascadeless）的。

并发控制策略有许多，<font color=red>本文主要集中在两阶段加锁（two-phase locking）和快照隔离（snapshot isolation）</font>。介绍完这两个并发控制协议后，再讨论各个隔离级别的实现，如何避免事务总论中提到的现象。

## Two-Phase Locking Protocol
为了简单，目前讨论的事务只有两种操作：访问（read）和更新（write），实际上还有如：插入（insert）、删除（delete）和含条件的读取（predicate read），它们会放在以后慢慢讨论。

同时，现在只讨论操作针对的是单个数据（如元组），这其实是锁的粒度问题，后面会讨论大粒度锁的情况。

为此，最简单的锁具有两种模式：
* 共享锁（shared-mode lock: S） 
* 排他锁（exclusive-mode lock: X）

在基于锁的的协议中，执行 read 操作时会对数据加共享锁，执行 write 操作时会对数据加排他锁，两种锁的相容性（compatibility）如下：

|   |S  |X  |
|:-:|:-:|:-:|
|S|true|false|
|X|false|false|

![事务3](/img/concurrency-control/txn-3.jpg)

### 两阶段加锁协议
<font color=dark-green>基础版两阶段加锁协议</font>
该协议要求一个事务请求加锁和释放锁分别集中在两个阶段：
* growing phase. 该阶段事务可以申请加锁，而不能释放任何锁
* shrinking phase. 该阶段事务可以释放锁，但不能申请新的锁

如图事务3满足两阶段加锁要求，需要注意，基本的两阶段加锁协议并不要求所有的释放锁操作都必须放在最后，如事务3将 unlock(B) 可以移到 lock-X(A) 后面，仍然满足两阶段加锁的定义。

<br>

<font color=dark-green>基础版两阶段加锁协议的特点</font>：
* <u>保证了 conflict serializability</u>. 假设一个调度内的事务都遵守该两阶段假设协议，同时将事务 growing phase 获取到的最后一个锁的位置定义为 lock-point，那么各个事务就可以根据其 lock-point 排序，该顺序一定是可串行化的。（证明：可以构造该调度的先行图，先行图有两种可能，要么无环，要么有环。若无环调度冲突可串行化；若有环，事务必然是相互等待对方到达 shrinking phase 释放冲突的锁，这是死锁。）
* <u>可能存在死锁</u>。如上
* <u>不能保证 recoverable 和 cascadeless rollback</u>.

先行图、recoverable 和 cascadeless 的定义见{% post_link 事务的可串行化 %}

<br>

<font color=dark-green>如何保证 recoverable 和 cascadeless？</font>
这里引入两种升级版两阶段加锁协议，一步到位之间使得满足这些协议的调度满足 cascadeless（自然就满足了 recoverable）。

**Strict Two-Phase Locking Protocol**: 
在基础版两阶段加锁协议上，增加了这样一条要求，所有的 exclusive-mode lock 必须要等到事务提交之后再释放。

**Rigorous Two-Phase Locking Protocol**：
在基础版两阶段加锁协议上，增加了这样一条要求，所有的 lock 必须要等到事务提交之后再释放。

解释下为什么满足 cascadeless：
> cascadeless 要求，若事务 A 依赖事务 B（事务 A 读取了事务 B 所做的更新），事务 A 必须要等事务 B 体提交后才能执行依赖的操作，由于事务 B 会拥有排它锁直到提交，自然就满足了这个要求。

这两种方式被广泛用于商业数据库系统中，也就是锁的释放通常要等到事务完成（提交或中止）。

<br>

<font color=dark-green>如何处理死锁？</font>
事务存在循环等待即进入了死锁，处理死锁一般有两种思路，这两种思路都会涉及到事务的回滚：
* <u>死锁避免</u>。该思路是让系统永远不会进入死锁状态，一般用于死锁发送频率高的场景中。
* <u>死锁检测 + 恢复</u>。该思路是在死锁发生后在人为干预，解除死锁状态，一般用于死锁发生频率较低的场景。

### 死锁避免
实现死锁避免也有许多思路：
* <u>破除循环等待条件</u>。实现方法有 1)通过给所有数据规定一个次序，加锁只能按该顺序加锁；2)事务开始之前完成对所有数据的加锁。最大的问题在于，如何准确的知道事务会涉及哪些数据。
* <u>基于抢占和回滚事务方式</u>。抢占很好理解，当两个事务发生冲突了，优先级高的事务可以让优先级低的事务回滚，下面主要介绍这种方式。


<font color=dark-green>基于抢占和回滚事务方式的死锁避免算法</font>
抢占需要确定优先级，下面的两个算法采用时间戳（timestamp）的方式决定优先级的大小。每个事务在其开始时得到一个时间戳，时间戳越小，代表事务越老，若事务回滚重新开始，那么它保持时间戳不变。注意，该时间戳只用于两个事务发生锁冲突时：
* <u>wait-die 算法</u>。当事务 TA 对某个数据加锁时，发现事务 TB 已经已经持有该数据的排它锁，若 TA 时间戳小于 TB 的时间戳，那么 TA 更老，选择等待；若 TA 的时间戳更大，则 TA 回滚。很明显，该算法不涉及抢占。该算法为何能避免死锁？因为它避免了循环等待的条件，假设形成了环，环首持有环尾需要的锁，那么环尾会直接回滚，矛盾。
* <u>wound-wait</u>。和上个算法不同的是，该算法涉及抢占，若 TA 的时间戳更小（TA 更老），那么 TA 会直接抢占该锁，TB 则回滚；若 TA 的时间戳更大，则 TA 等待。其避免死锁的证明同上。

以上两个算法最大的缺点在于可能会造成不必要的回滚，一个简单的优化是在回滚之前先等待一段时间，不过这段时间对每个事务最好是随机的，而且其长度难以确定。

死锁检测与恢复不想写了，有时间再写吧。

### 更丰富的锁粒度
一个简单的例子，当锁粒度只有元组时，一个事务想更新一张表，那它就必须对表的所有元组加锁，显然不合适，反之，若只更新几个元组，用不上对整张表加锁。

多粒度一般采用分级结构实现，该结构可以称为 multiple-granularity tree，如下图：
![](/img/concurrency-control/multiple-granularity.jpg)

（未完待续）

## Snapshot Isolation
快照隔离（snapshot isolation）属于多版本并发控制技术的一种。多版本并发技术通过维护一份数据的多个版本，让事务可以访问（read）数据的最新的已提交版本，而不是当前未提交事务正在修改的版本（该未提交事务可能更老，即开始于当前事务之前；也可能发生在未来，即如果按照串行执行，当前事务本应该看不到后面事务的更新，但并发执行，就有可能了）。

版本的概念并不容易理解，后面详细介绍 snapshot 后，再理解它在 percolator 的实现，这样就清楚得多了。

<br>

<font color=dark-green>基本概念</font>
当事务开始执行时，数据库给该事务一个 snapshot，里面包含的是该事务需要的、最新的已被提交的数据，之后该事务对数据的所有操作都在该 snapshot 上操作（该 snapshot 暂存在事务私有内存中，其他事务不可见）。对于只读事务，操作完就可以结束了（提交或者失败），不需要等待，也不会因为并发而被回滚；对于更新事务，它还需要将更新写入数据库（写入应当是一个原子操作），因此还涉及到一个验证步骤，后面会详细结束。

在快照隔离中，只读事务不需要等待，也不会 abort，<font color=red>那会不会有不可重复读的可能呢？毕竟多次读取，可不可能在某一次就读到了刚刚被更新的值呢？</font>不会的，因为读取到快照后，该快照被该事务独享（或者说被只读事务共享），不会涉及到更新。

<br>


<font color=dark-green>实现细节</font>
该协议给进入系统的每个事务两个时间戳：
* <u>startTS</u>. 在事务开始时获取
* <u>commitTS</u>. 在事务准备写入更新到数据库时获取（或者是开始验证阶段时获取）

每个被更新的数据都带有一个时间戳（即数据的版本号），它等于执行该更新事务的 commitTS，也就是说同一份数据可能存在多个版本。时间可以是系统时间，也可以是逻辑时间（计数器），只要保证不会存在相同的时间戳即可。

当一个事务 TA 读取一个数据时，读取到的数据具有这样的特点：在所有版本号小于等于 startTS(TA) 的数据中具有**最大的版本号**。从事务角度理解，一个事务看不到，任何在该事务开始之后提交的事务所作的更新。

<br>

<font color=dark-green>更新验证阶段</font>
按照上面所说，事务读取数据后各自操作，其他事务感知不到，那么就可能会出现两个并发的事务更新同一个数据，如果允许这两个事务都修改数据库，那么就会发生值覆盖，也就是更新丢失（lost update）。如何解决冲突，是验证阶段的工作。

一般有两种方法可以防止更新丢失，介绍之前先看一下 snapshot isolation 中的并发定义，若 TA 和 TB 的更新存在交集，当下面情况中任一发生时，就说事务 TA 和 TB 并发：
* startTS(TA) <= startTS(TB) <= commitTS(TA)
* startTS(TB) <= startTS(TA) <= commitTS(TB)

**第一种方法称为先提交先获胜（first committer wins）**. 
> 在该方式中，当事务 TA 来到验证阶段时，先获取提交时间戳 commitTS(TA)，然后执行下面的步骤：
> * 检查<u>每一个</u> TA 更新的数据，看该数据是否已经存在一个落在 [startTS(TA), commitTS(TA)] 区间的版本。
> * 如果存在这样的数据，TA abort.
> * 如果<u>所有数据</u>都通过检查，TA 将其更新写入数据库，然后提交。

<br>

**第二种方法称为先更新先获胜（first updater wins）**. 
> 在该方式中，当事务 TA 尝试更新一个数据时，先获取该数据的排它锁，<u>如果该锁获取成功</u>，执行下列步骤：
> * 如果该数据已经被并发事务更新了（也可以通过获取一个时间戳来判断），则 TA abort.
> * 如果该数据没有被并发事务更新，则 TA 写入更新到数据库（结合其时间戳），然后继续其常规流程。
>
> 但是，如果该数据的排它<u>锁已经被并发事务 TB 持有</u>，TA 选择等待下面的事情发生：
> * TB abort，则 TA 就可以再次申请该锁，重复上述步骤。
> * TB commit，则 TA 只有 abort 了。
>
> 这个过程获取的排它锁会一直持有直到事务提交或中止


<br>

<u>比较一下这两种方式</u>，先提交先获胜其实是将所有更新操作本地执行完后，统一提交时刻验证，可以将其所有的数据验证看成一个原子操作，这也是为什么它叫做先提交先获胜。先更新先获胜中，只要是更新某个数据，就进入验证阶段，每一个数据的更新都会有一个验证步骤。如果发生冲突了，先提交先获胜不会回滚数据库中的更新，而先更新先获胜则会。

> tips：多版本并发控制是一种乐观并发控制。何为乐观？先对数据执行操作，更新时才检测是否冲突。何为悲观？先对要操作的数据加锁，再对数据执行操作。上面的两种方式都属于乐观派，在 TiDB 的悲观 MVCC 实现中，当 SQL 语句被解析后就对涉及到的数据加锁，然后再开始乐观的 MVCC，具体见[文章](https://docs.pingcap.com/zh/tidb/stable/pessimistic-transaction)。

<br>

<font color=dark-green>Snapshot Isolation 问题与解决</font>
snapshot isolation 吸入的地方在于，读写分离，互不干扰。**但它有一个致命的缺陷：不保证可串行化（serializability）**，如下例子：
![](/img/concurrency-control/snapshot-isolation-1.jpg)

如果构造该例子的先行图，会发现存在环：该调度非冲突可串行化。在两阶段加锁协议中该调度会产生死锁，不可能顺利执行下去。然而，在快照隔离策略中却可以执行、提交。如果这两个事务以可串行化的调度方案并发，那么 A、B 的值是一样的，具体的值取决于谁先执行，而快照隔离的结果却是将它们的值交换。

**这种现象被称为写偏斜（write skew）**：两个并发的事务读取了对方会更新的数据，但这两个事务更新的数据却没有交集，如 Ti 读取了会被 Tj 更新的 B，Tj 读取了会被 Ti 更新的 A，而它们分别更新 A 和 B，没有交集，所以在验证阶段无法被检测出来。

<font color=red>发生写偏斜的根本原因是什么？snapshot isolation 不能有效追踪防止 read-write conflict，验证阶段的两个方法都只限制了 write-write conflict</font>. 借助上面例子可以发现，发生写偏斜时，调度方案的先行图存在两条 read-write 冲突边，一条入边，一条出边：对于事务 Ti 写入了 A 的一个新版本，而 Tj 读取了 A 之前的一个版本（Tj -> Ti, read-write edge）；对于事务 Tj 写入了 B 的一个新版本，而 Ti 读取了 B 之前的一个版本（Ti -> Tj, read-write edge）：
![](/img/concurrency-control/snapshot-isolation-2.jpg)

**由此，一种称为 Serializable Snapshot Isolation(SSI) 的新技术被提出以保证快照隔离可串行化**。SSI 会追踪并发事务之间的所有 read-write 冲突，检查是否同时存在出边和入边，如果存在，则其中一个事务会被回滚。


趁热打铁读一读 snapshot isolation 的工业级实现：{% post_link Percolator-随笔 %}呀。


## 隔离级别的实现
<font color=dark-green>如何实现读已提交级别？</font>
读已提交有如下特点：
* 从数据库中读时，只会读到已经提交了的数据，即<u>没有脏读（dirty read）</u>
* 写入数据库时，只会覆盖已经提交的数据，即<u>没有脏写（dirty write）</u>
* 可能发生不可重复读异常

**何为脏读？**能读取到尚未 commit/abort 事务所做的更新，就叫脏读。脏读可能引发只能看到部分更新的问题，比如转账事务提交前就读取余额，很可能会出现账户余额蒸发的怪现象。

**何为脏写？**当两个事务更新同一对象时，通常后者会覆盖前者所做的更新，但若是覆盖的是尚未 commit/abort 事务的更新，就叫做脏写。脏写同样会产生问题，考虑自动发送邮件例子，一个事务刚刚填入收件人地址，还未提交，另一个事务却覆盖了这个邮件地址，邮件就会发往错误的地方。

一般数据库通过行锁（row-level lock）**防止脏写**。当事务想要修改特定对象时，它必须首先获得该对象的排它锁，持有到事务提交或中止。可以通过读锁**防止脏读**，然而该方法中，写事务会阻塞读事务，所以数据库通常会为数据保留一个最近的已提交的旧值，和正在更新的新值，若新值还未提交，任何读事务都会拿到旧值，若新值提交了，就会读到新值（发生不可重复读异常）。



<br>

<font color=dark-green>如何实现读未提交级别？</font>
读未提交有如下特点：
* 写入数据库时，只会覆盖已经提交的数据，即<u>没有脏写（dirty write）</u>
* 可能发生脏读
* 可能发生不可重复读异常

防止脏写的实现方式和读已提交级别一致。

<br>

> 不可重复读异常可能引发一致性问题。假设数据库中存在两个字段 A、B，这两个字段需要时时刻刻相等（数据约束）。假设一个并发调度为 T1-read(A), T2-write(A,B), T1-read(B)，如果允许不可重复读异常，那么事务 T1 读取出来的 A 和 B 不满足约束条件，在外部看来这是一个不一致状态。

<br>

<font color=dark-green>如何实现可重复读级别？</font>
可重复读有如下特点：
* 没有脏读
* 没有脏写
* 不会发生不可重复读异常
* 若使用快照隔离提供稳定的视图，则不会出现幻读

读已提交维护数据的两个版本，但可能会读取到已提交的新值，而对于可重复读级别，可以使用快照隔离，让事务始终读取最开始读取的那一个版本，维持稳定的视图，来**防止不可重复读异常，同时也解决了幻读异常**。

这里再解释下幻读。下面是一张教师（instructor）薪资表：

|ID  |name |salary|
|:-: |:-:  |:-:   |
|001 |Jery |1000  |
|002 |Peter|2000  |
|003 |Tim  |3000  |

现在执行如下的 SQL 语句：

**select** *ID*, *name*    
**from** *instructor*    
**where** *salary* > 1000

假设当前系统采用可重复读隔离级别，一个用户执行了如上的查询，同时另外一个用户执行了如下的插入语句（删除语句也有如下的效果）：
**<center>insert** **into** *instructor* **values** (004, James, 4000)</center>
查询事务读取到多少条的数据取决于它和插入事务的先后顺序，若查询事务多次读取，就有可能发生某次读到的内容比上次多，即发生了幻读。

<br>

> 幻读异常可能引发一致性问题。假设表中某个数据列与另外一个数据列的数据是一一对应的，系统有这样的并发调度：T1-read(col1 > A), T2-insert(col1=A+1, col2=A+1), T1-read(col2 > A)，如果允许幻读，那么事务 T1 读出的 col1 > A 的数据条数与 col2 > A 的条数是不一致的。

<br>

<font color=dark-green>如何实现可串行化级别？</font>
采用 SSI 和 两阶段加锁都可以实现。


> 脏写对一致性的影响实在太严重了，所以所有的隔离级别都不允许脏写的发生。









