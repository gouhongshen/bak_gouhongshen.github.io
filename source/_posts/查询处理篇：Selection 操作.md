---
title: 查询处理篇：Selection 操作
date: 2022-07-15 14:29:05
tags:
sticky: 1
math: true
---

> 假设一张表的所有记录都存储在一个文件中，并且该文件的 block 在磁盘上连续存储，这样计算起来简单些 ^_^

本文研究选择操作 $\sigma_{expression}$，下面分各种情况介绍操作的执行过程和代价。

### 采用线性扫描
线性扫描也就是从文件的第一个 block 开始，读取每一条记录，判断它是否满足选择条件（$expression$），这种方法的好处是在任何情况下都可以用，虽然可能性能不好。

如果选择条件是 non-key 上的等值判断或比较，<u>那么它的代价为</u>：
$$ t_S + b_r * t_T $$
> 其中 $b_r$ 表示文件总共包含多少个 block. 在扫描过程中，初始需要一次随机 I/O 找到第一个 block，满足条件的记录可能不止一条，而线性扫描又不考虑有序之类的情况，所以必须扫描全文件。

</br>

如果选择条件是 key 上的等值判断，<u>那么它的代价为</u>：
$$ average = t_S + \frac{b_r}{2} * t_T $$
> 这个也挺好理解的，key 是不重复的，满足条件的记录最多只有一条，所以平均来说，只需扫描一半的 block.

</br>

下面讨论使用索引的情况（当然假设相应的索引存在，叶子节点存储指向记录的指针）。这里只涉及 B+ 树索引，使用 $h_i$ 表示树高（从根节点到叶子节点需要访问 block 的数量），并且考虑没有节点提前驻留在内存中，下同。事实上，B+ 树的节点有 90% 是叶节点，非叶子节点很少，因此绝大多数数据库系统会提前将所有非叶子节点读取到内存中，因此 $h_i$ 在绝大多数情况下等于 1，不过这里不做这个假设。下面提到的 key/non-key 表示主键（primary key），与索引的 search key 没有必然的联系，相关讨论见 {% post_link "索引篇零：索引总论" %}。

### 使用 B+ 树 Primary Index
如果选择条件是 key 上面的等值判断，<u>那么它的代价为</u>：
$$ (h_i + 1) * (t_T + t_S) $$
> 从根节点到叶节点需要读取 $h_i$ 个 block 到内存中，它们不太可能是连续的，所以为了读取包含目标 search key value 的 block 分别需要 $h_i$ 次随机访问（定位 block）和 $h_i$ 次 block 传输，再分别需要额外的 1 次随机 I/O 和 block 传输获取指定的记录。

<br>

如果选择条件是 non-key 上面的等值判断或比较，<u>那么它的代价为</u>：
$$ h_i * (t_T + t_S) + t_S + b * t_T $$
> 该 search key 非主键，所以不一定唯一，存在多条 search key value 相等的记录。又因为这是 primary index，所以 search key value 相等的记录在文件中必然连续存储。无论是等值判断还是比较，都会找到满足条件的第一条记录，然后顺序扫描即可。从根节点找到包含第一条记录指针的叶节点需要 $h_i$ 随机 I/O 和 block 传输，然后根据该指针，再一次随机 I/O 定位到包含第一条记录的 block（中的该记录的偏移量），假设这些 search key value 相等的记录存储在连续的 $b$ 个 block中，需要再加上 $b$ 次 block 传输。

### 使用 B+ 树 Secondary Index
如果选择条件是 key 上面的等值判断，<u>那么它的代价为</u>：
$$ (h_i + 1) * (t_T + t_S) $$
> 没什么好解释的，最多只读取一条记录，和使用 B+ 树 primary index 时在 key 上面等值判断情况一致。

<br>

如果选择条件是 non-key 上面的等值判断或比较，<u>那么它的代价为</u>：
$$ (h_i + n) * (t_T + t_S) = h_i * (t_T + t_S) + n * (t_T + t_S) $$
> 同样的，满足条件的记录可能存在多条，因此需要 $h_i$ 次随机 I/O 和 block 传输将叶子节点读取到内存中。该叶子节点包含满足条件的第一条记录的指针，从该指针开始顺序扫描索引（可能跨越多个叶子节点），就能获取到所有指向满足条件的记录的指针，假设有 $n$ 条。它们的指针虽然在索引中顺序存储，但这是 secondary index，指针指向的记录却可能分布在不同的 block 中，所以要获取到这些记录，最多还需要 $n$ 次随机 I/O 和 block 传输。

从这里可知，如果满足条件的记录非常多，那么 secondary index 的代价很可能比线性扫描还要高！！！**所以 secondary index 只适合少量记录读取的情况**。

如果提前就知道需要读取记录的多少，那么就能在没有其他索引可用时在 secondary index 和线性扫描中选择最好的方案（即操作的注释，{% post_link "查询处理篇：总论" %}），事实上很难提前得知。<u>为了应对这种情况</u>，PostgreSQL 使用了一种混合方法，bitmap index scan. 
> search key value 在叶子节点中是按序存储的，在这些叶子节点上再建立多级稀疏索引，就能够跳过大量无效的记录。这是索引的最大好处。然而，secondary index 中相邻 search key value 指向的记录可能存储在不同的 block 中，会存在大量的随机 I/O，比较耗时。<u>bitmap index scan 便是从这点下手</u>，该算法首先会为该表创建一个 bitmap，1bit 对应一个 block，当使用 secondary index 检索记录时，不着急读取指针所指的 block，而是获取该 block 编号，再将 bitmap 中该编号对应的位置 1，待所有包含目标记录的 block 都被标记完后，顺序扫描该 bitmap，读取那些被置 1 的 block，没有置 1 的就跳过，最后在这些 block 中检索目标记录。这样记录的读取就尽量做到了顺序扫描。




























































































