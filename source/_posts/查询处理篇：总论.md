---
title: 查询处理篇：总论
date: 2022-07-01 16:23:09
tags:
sticky: 999
math: true
---

## 前言
查询处理（Query Processing）指的是那些涉及从数据库中读取数据的操作（不包括写，当然了，如果有必要，本部分也会涉及）。

本部分讨论的单机数据库中（后面有时间会拓展到并行/分布式系统），这些单个的查询操作执行的过程以及如何衡量它们的代价等等。

</br>

<font color=red>单机部分</font>
{% post_link "查询处理篇：Selection 操作" %} </br>
{% post_link "查询处理篇：Join 操作" %} </br>
{% post_link "查询处理篇：Sorting" %} </br>
{% post_link "查询处理篇：查询执行模型" %} <br>

</br>

<font color=red>并行/分布式部分</font>
{% post_link "查询处理篇：Parallel Join" %} </br>
{% post_link "查询处理篇：Parallel Sort" %} </br>

## 前置知识
![](/img/query_processing_0/0.jpg)
如上图，执行一条 query 的步骤通常包括以下三步：
* parsing and translation：将 sql 语句翻译成关系代数（relational algebra）。
* optimization：衡量代价，选择合适的执行方案（query-execution plan）。
* evaluation：执行具体的方案，然后输出结果。

optimization 和 evaluation 内容很多，可以分为三部分：
1. 将关系代数做等价变换，生成多个不同的执行方案
2. 衡量每个执行方案的代价，选择最优的一个作为最后方案
3. 执行方案。

第 1、2 部分将在{% post_link "查询优化（Query Optimization）"%}介绍，<u>本部分（查询处理篇）主要涉及 3 执行方案中的单个操作的执行和代价衡量</u>，参考下面例子：
![](/img/query_processing_0/1.jpg)

假设有一个 query 如上图，经过 parsing and translation 可以产生如下的代数表达式：

![](/img/query_processing_0/2.jpg)

其中 $\Pi,\\ \sigma$ 分别表示投影（projection）和选择（selection）操作。有了表达式还不够，代数表达式包含多个操作，所以还需要告诉数据库系统应该如何执行这一系列操作，比如应该如何执行 $\sigma_{salary< 7500}$ 这个操作，是顺序读取表文件还是采用索引，这个步骤称为注释（annotation）。一个代数表达式操作 + 注释被称为执行原语（evaluation primitive），如 $\sigma_{salary< 7500}\\ (use\\ index\\ 1)$，执行一条 query 所包含的一组执行原语就叫做**执行方案或执行计划（query-execution plan）**.

<font color=red>执行一个方案需要执行方案中的每一个操作，本部分的内容就是研究每个操作是如何执行的，以及衡量它们的代价</font>.

## 代价模型（Cost Model）
这里介绍在后续篇章中使用的衡量操作代价的模型，在 PostgreSQL（2018）中代价包括：
1. 每个元组的的 CPU 开销
2. 每个 Index entry 的 CPU 开销
3. 每个其他操作（如数学运算、比较、函数）等的 CPU 开销
4. I/O 开销

一般数据库对上述参数都有默认值，为了简单起见，本部分以 I/O 开销为主要因素衡量代价，主要有：需要传输的 block 数量和随机 I/O 访问次数。用 $t_T,\\ t_S$ 分别作为传输一个 block 的时间和寻道等（包含旋转延迟）时间，若一个操作需要传输 $b$ 个 block，执行 $S$ 次随机访问，那么总的开销为 $b * t_T + S * t_S$ 秒。

另外，buffer pool 的数量也很重要，在该模型中使用 $M$ 衡量。





