---
title: 查询处理篇：查询执行模型
date: 2022-08-24 15:59:07
tags:
---

在{% post_link "查询处理篇：总论" 总论篇 %}中提到了用户编写的 SQL 语句最终会被转换成具体的执行计划。一个执行计划会包含很多操作，比如选择、投影、join、sort、aggregation 等等，在其他篇章中也介绍了完成这些操作的可以采用的算法。本文主要是讨论以何种方式执行一条执行计划，如何组织这些操作。

为了避免陷入细节，先以代数表达式介绍一般的执行模型，后面再讨论具体的执行计划是怎么做的。
> 执行计划 = 代数表达式 + 完成各个操作的具体算法

<br>

以该表达式为例：$\Pi_{name} (\sigma_{building=Watson}department)\bowtie instructor)$.

不考虑查询优化，上面的表达式可以用一个算子树（operator tree）表示：
![](/img/evaluate_expression/1.jpg)
> 很明显，树中共有三个算子：选择、连接和投影。

执行这个表达式有一个很直观的思路：先在 department 表上执行 $\sigma_{building=Watson}$ 操作（具体算法可以是顺序扫描、索引或排序），将满足条件的元组写入一个临时表中。然后以上一步生成的临时表和 instrutor 为输入执行 $\bowtie$ 操作（具体算法可以是 hash join、merge join 或其他），将满足条件的元组写入一个临时表中。最后再在临时表上执行 $\Pi_{name}$ 操作，将生成的元组返回给用户。**这种方法被称为物化执行（materialized evaluation）**，如下图：
> ![](/img/evaluate_expression/3.jpg)
> 如果采用物化的方式计算一条表达式，在执行过程中会产生临时表（图中的 out[]），如果该表很大（buffer pool 装不下），那就需要将该表写入磁盘，执行其他算子时再读出，所以其代价需要加上磁盘读写开销。可以使用**双缓冲策略**，一个用于缓冲读入、一个用于缓冲写出，这样一来就可以减少算子等待 I/O 的时间。

<br>

可以换一个思路：没必要为所有的中间过程都创建一个临时表，而是产生一部分结果后就返回它们。以 $\Pi_{a_1, a_2}(r \bowtie s)$ 为例，如果采用物化方式，那么需要一个临时表来存储表 r 和 s join 的结果，然后再在临时表上执行投影操作；但该临时表不是必须的，可以这样，每当 join 操作生成了一些满足条件的元组后，就立即将其发送给 $\Pi$ 算子，因为元组数量少可以保留在内存中，就避免了创建临时表额外读写磁盘的开销。**这种方式被称为流水线执行（pipelined evaluation）**. 使用流水线方式可以提供以下优点：
> * 避免了磁盘读写临时表，减少了查询执行的开销。
> * 能够减少查询的响应时间。采用 pipeline 后，一部分结果生成后就会立马返回，用户不需要长时间的等待完整的结果生成。


流水线执行方式一般有两种模式：
* **Demand-Driven Pipeline**. 又称为迭代器模型或火山模式。在该模式中，可以通过迭代器（iterator）实现算子。迭代器包含 open()、next() 和 close() 等方法. open() 一般用来初始化算子，比如在 merge join 算子中，open 就可以对表排序；调用 open() 之后，每一次调用 next() 都会返回若干个（一个或一批）该算子生成的元组，如 join 的结果；当不需要更多的元组时，就可以调用 close()，该函数可以完成一些内存回收等工作，如下图（左边是 batch，右边是单个元组）：
> ![](/img/evaluate_expression/2.jpg)

<br>

* **Producer-Consumer Pipeline**. 在该模式中，算子树中相邻的两个算子（父子）之间有一个缓冲. 当一个算子（线程或进程）需要元组时就去其输入缓冲中读取（最底层算子会直接读表），若输入缓冲为空，该算子等待；当算子产生结果时就将其写入输出缓冲中，若输出缓冲满了，该算子等待。各算子同时表现为消费者和生成者。


demand-driven pipeline 的工作模式是由上层算子驱动的，可以理解为 pull data，是一种懒汉模式. 而 producer-consumer pipeline 的工作模式则更加主动，每个算子都就可能的计算，可以理解为 push data，是一种饿汉模式。demand-driven pipeline 用得比较多，因为简单容易实现，但 producer-consumer pipeline 在多处理器（并行处理）系统中有更高的性能，因为各算子可以并行计算。

