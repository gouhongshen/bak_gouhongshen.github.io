---
title: 索引篇四：Parallel Index
date: 2022-08-03 19:08:51
tags:
sticky: 1
---

当数据分片后，在这些分片之上建立的索引可以分为两类（下面的一个节点代表/存储一个分片）：
* <u>局部索引（local indices）</u>，指的是那些构建在某个具体分片之上的索引。索引内容和数据存储在同一个节点。
* <u>全局索引（global indices）</u>，指的是那些构建在多个分片之上的索引，能够在众多分片之上提供高效的查找操作。索引内容一般也会分片存储在不同的节点上（为了增强拓展性）。

如果一个全局索引建立在分片属性上，就称该索引为**全局主索引（global primary index）**。如分片方法涉及的属性为 $K$，建立在 $K$ 上的全局主索引实际上只是在每个分片上都建立了一个关于 $K$ 的局部索引。当一个请求想要查询一条 $K = k_1$ 的数据时可以通过全局主索引：先通过分片方法确定 $k_1$ 属于哪一个分片，然后再到这个分片上通过建立在 $K$ 上的索引查找。

如果一个全局索引没有建立在分片属性上，就称该索引为**全局二级索引（global secondary index）**，如分片的属性为 $K_p$，索引属性为 $K_i$，且 $K_p \ne K_i$. 现在来看一下如何通过全局二级索引检索一条 $K_i = k_1$ 的数据。第一种方法是，可以在每个分区上都建立一个关于 $K_i$ 的局部索引，当请求到来时，该请求会被发送到每一个分区上进行检索。这个方法有点低效，基本不使用，下面阐述实际更加高效的做法。

假设有一张 student 表，属性值有：[id, name, dept_name, grad]，分片属性为 id. <u>为了提供在 name 上的高效查询</u>，我们在 name 属性上构建一个全局二级索引：首先为 student 的每一条元组都创建一条 [name, id] 元组，假设这些新创建的元组构成一个新表 index_name，然后将 index_name 以 name 属性分片，再在每个分片上建立关于 name 的局部索引，最后在 id 上再建立一个全局主索引（也就是在 student 表的每个分区上建立一个关于 id 的局部索引）。当一个请求想要检索某条包含具体名字，假设为 $n_1$，的数据时，可以通过如下的步骤：
* 通过 index_name 的分片方法找到包含 $n_1$ 的分片；
* 路由到分片上，检索 name 上的局部索引，找到对应的 id（可能有多个）；
* 最后通过构建在属性 id 上的全局主索引找到对应的数据。

这个方法只会涉及到部分的分片，比上面的方法要高效得多。上面是一个例子，<u>下面给出更加形式化的描述</u>：一般地，给定一个表 $r$，它的分片属性为 $K_p$，如果要提供关于属性 $K_i,\\ \\ K_p \ne K_i$ 的高效检索，就需要在 $K_i$ 上构建一个全局二级索引。首先，创建一个包含下列属性的表 $r_i^s$：
* $K_i$ 和 $K_p$.
* 如果分片属性 $K_p$ 不是主键或者候选键，那么就可能存在重复，所以还得再加入其他属性，假设 $K_u$，使得 $K_p \cup K_u$ 为表 $r$ 的主键或者候选键，这样就能唯一标识 $r_i^s$ 的一条元组。

即 $r_i^s = \Pi_{K_i,\\ K_p,\\ K_u}(r)$. 然后将 $r_i^s$ 按照 $K_i$ 分片，在每个分片上构建关于 $K_i$ 的局部索引，最后在表 $r$ 的每个分片上构建关于 $(K_p,\\ K_u)$ 的局部索引。

此时查询就可以采用如下的步骤：
* 通过表 $r_i^s$ 的分片方法找到请求中 $K_i=v$ 所在的分区。
* 路由到分区后，在 $K_i$ 局部索引上找到包含 $v$ 的元组 [$v,\\ V_{K_p},\\ V_{K_u}$]（可能多个）. 
* 然后根据 $V_{K_p}$ 和表 $r$ 的分区方法找到 $V_{K_p}$ 所在的分区。
* 最后路由到分区检索 $(K_p,\\ K_u)$ 属性上的局部索引，找到包含 $v$ 的数据。

建立全局二级索引的方式其实和在 secondary index 叶子节点中存储 primary index 检索键值是一样的。上面提到的属性并不一定只有一个，如 $K_p$ 也可能是一组属性的集合；当 $r$ 中的数据变更时（插入、删除、更新等）$r_i^s$ 及其相关的局部索引也需要更新，所以在实现中，更新 $r_i^s$ 及索引也会作为 $r$ 分布式事务的一部分。

<u>后两个步骤称之为回表（{% post_link "索引篇二：B-plus Tree" %}中也提到了）</u>。在某些情况下，可以通过覆盖索引（covering index）技术减少回表带来的性能损失。
> 覆盖索引是什么？索引确实是一种查找数据的高效方式，但是也可以使用索引来直接获取列的数据，这样就不再需要读取数据行（或再去 primary index 中查询）。如果索引的叶子节点中已经包含要查询的数据，那么还有什么必要再回表查询呢？如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。

> 覆盖索引需要保存除了 search key 之外的其他属性值，可以通过组合索引的方式来建立。



<br>

<font color=red>还有个疑问：为什么要凑出 $(K_p,\\ K_u)$，使得 [$v,\\ V_{K_p},\\ V_{K_u}$] 唯一呢？</font>